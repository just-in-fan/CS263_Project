# Generated by Google Gemini: 2.5 Pro on 12/4/2025 5:35 pm
# https://gemini.google.com/share/0d5302119bf0
from typing import Dict, List, Tuple
import heapq

Node = int
Weight = float
Graph = Dict[Node, List[Tuple[Node, Weight]]]

def dijkstra(graph: Graph, source: Node) -> Dict[Node, float]:
    """
    Compute the shortest path distance from `source` to every reachable node
    in a directed graph with non-negative edge weights using a priority queue.

    - `graph[u]` is a list of (v, w) edges meaning an edge u -> v with weight w.
    - Returns a dict `dist` where `dist[u]` is the distance from `source` to u.
    - Nodes unreachable from `source` are omitted from the result.
    """
    # distances[node] holds the shortest known distance to node so far
    distances: Dict[Node, float] = {source: 0.0}
    
    # Priority queue stores tuples of (current_dist, node)
    # Initialized with the source node at distance 0
    pq: List[Tuple[float, Node]] = [(0.0, source)]

    while pq:
        current_dist, u = heapq.heappop(pq)

        # If we found a shorter path to u previously, skip this stale entry
        if u in distances and current_dist > distances[u]:
            continue

        # Explore neighbors if the node has outgoing edges
        if u in graph:
            for v, weight in graph[u]:
                new_dist = current_dist + weight

                # If a shorter path to v is found, update it and push to the queue
                if v not in distances or new_dist < distances[v]:
                    distances[v] = new_dist
                    heapq.heappush(pq, (new_dist, v))

    return distances