# Generated by DeepSeek: V3.2 on 12/4/2025 5:34 pm
# https://chat.deepseek.com/share/o7ovo799289t5tn9hm
from typing import Dict, List, Tuple
import heapq

Node = int
Weight = float
Graph = Dict[Node, List[Tuple[Node, Weight]]]

def dijkstra(graph: Graph, source: Node) -> Dict[Node, float]:
    """
    Compute the shortest path distance from `source` to every reachable node
    in a directed graph with non-negative edge weights.

    Args:
        graph: Adjacency list representation. graph[u] is a list of (v, w) edges
               meaning an edge u -> v with weight w.
        source: The starting node for shortest path computation.

    Returns:
        A dict `dist` where `dist[u]` is the distance from `source` to u.
        Nodes unreachable from `source` are omitted from the result.
    """
    # Initialize distances: source is 0, others unknown (effectively infinity)
    dist = {}
    pq = []  # min-heap priority queue
    
    # Start from source node
    heapq.heappush(pq, (0.0, source))
    
    while pq:
        current_dist, u = heapq.heappop(pq)
        
        # If we've already found a shorter path to u, skip
        if u in dist and current_dist > dist[u]:
            continue
            
        # Record the shortest distance to u
        dist[u] = current_dist
        
        # Explore neighbors of u
        for v, w in graph.get(u, []):  # Use .get() in case node has no outgoing edges
            new_dist = current_dist + w
            
            # Only consider this path if v is unvisited or we found a shorter path
            if v not in dist or new_dist < dist.get(v, float('inf')):
                heapq.heappush(pq, (new_dist, v))
    
    return dist