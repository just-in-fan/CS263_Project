# Generated by Google Gemini: 2.5 Pro on 12/3/25 8:18 pm
# https://gemini.google.com/share/1fdf38c6a021
import heapq
from typing import Dict, List, Tuple

# Type Aliases
Node = int
Weight = float
Graph = Dict[Node, List[Tuple[Node, Weight]]]

def dijkstra(graph: Graph, source: Node) -> Dict[Node, float]:
    """
    Compute the shortest path distance from `source` to every reachable node
    in a directed graph with non-negative edge weights.

    - `graph[u]` is a list of (v, w) edges meaning an edge u -> v with weight w.
    - Return a dict `dist` where `dist[u]` is the distance from `source` to u.
    - Nodes unreachable from `source` are omitted from the result.
    """
    # Dictionary to map node -> shortest distance found so far.
    # We initialize the source with a distance of 0.0.
    distances: Dict[Node, float] = {source: 0.0}
    
    # Priority queue (min-heap) to store (distance, node).
    # Initialized with the source node.
    pq: List[Tuple[float, Node]] = [(0.0, source)]

    while pq:
        # Pop the node with the smallest distance
        current_dist, u = heapq.heappop(pq)

        # Optimization: If the popped distance is greater than the shortest distance
        # we've already recorded for u, we skip it (stale entry in the heap).
        if current_dist > distances[u]:
            continue

        # Iterate over neighbors of u.
        # graph.get(u, []) handles cases where u has no outgoing edges.
        for v, weight in graph.get(u, []):
            new_dist = current_dist + weight

            # If we found a shorter path to v, update the distance and push to heap.
            # v not in distances implies distance is infinity.
            if v not in distances or new_dist < distances[v]:
                distances[v] = new_dist
                heapq.heappush(pq, (new_dist, v))

    return distances