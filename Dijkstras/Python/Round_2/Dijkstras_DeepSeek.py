# Generated by DeepSeek: V3.2 on 12/4/2025 5:23 pm
# https://chat.deepseek.com/share/s4qjn47qwdtdnh8ufm
from typing import Dict, List, Tuple
import heapq

Node = int
Weight = float
Graph = Dict[Node, List[Tuple[Node, Weight]]]


def dijkstra(graph: Graph, source: Node) -> Dict[Node, float]:
    """
    Compute the shortest path distance from `source` to every reachable node
    in a directed graph with non-negative edge weights.

    - `graph[u]` is a list of (v, w) edges meaning an edge u -> v with weight w.
    - Return a dict `dist` where `dist[u]` is the distance from `source` to u.
    - Unreachable nodes are included in the result with distance float("inf").
    """
    # Initialize distances: infinity for all nodes, 0 for source
    dist = {}
    for node in graph:
        dist[node] = float('inf')
        for neighbor, _ in graph[node]:
            dist[neighbor] = float('inf')
    
    # Ensure source node exists in distance dict
    dist[source] = 0.0
    
    # Min-heap priority queue: (distance, node)
    pq = [(0.0, source)]
    
    while pq:
        current_dist, u = heapq.heappop(pq)
        
        # Skip if we found a better path already
        if current_dist > dist[u]:
            continue
        
        # Explore neighbors if node exists in graph
        if u in graph:
            for v, weight in graph[u]:
                if weight < 0:
                    raise ValueError("Edge weights must be non-negative")
                
                new_dist = current_dist + weight
                if new_dist < dist[v]:
                    dist[v] = new_dist
                    heapq.heappush(pq, (new_dist, v))
    
    return dist