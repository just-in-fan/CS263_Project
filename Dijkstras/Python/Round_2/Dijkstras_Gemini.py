# Generated by Google Gemini: 2.5 Pro on 12/4/2025 5:24 pm
# https://gemini.google.com/share/2101c84efeea
import heapq
from typing import Dict, List, Tuple

# Type Aliases
Node = int
Weight = float
Graph = Dict[Node, List[Tuple[Node, Weight]]]

def dijkstra(graph: Graph, source: Node) -> Dict[Node, float]:
    """
    Compute the shortest path distance from `source` to every reachable node
    in a directed graph with non-negative edge weights.

    - `graph[u]` is a list of (v, w) edges meaning an edge u -> v with weight w.
    - Return a dict `dist` where `dist[u]` is the distance from `source` to u.
    - Nodes unreachable from `source` are omitted from the result.
    """
    # Dictionary to map nodes to their current shortest distance from source
    # We initialize it with the source node at distance 0.0
    dist: Dict[Node, float] = {source: 0.0}
    
    # Priority queue to explore nodes, storing tuples of (distance, node).
    # Initialized with the source node.
    pq: List[Tuple[float, Node]] = [(0.0, source)]
    
    while pq:
        # Pop the node with the smallest distance
        current_dist, u = heapq.heappop(pq)
        
        # If we found a shorter path to u before processing this entry, skip it
        # (Lazy deletion strategy for the priority queue)
        if current_dist > dist[u]:
            continue
        
        # Explore neighbors
        # We use .get() to handle cases where a node acts as a sink (has no outgoing edges)
        # and might not be present as a key in the graph dictionary.
        for v, weight in graph.get(u, []):
            new_dist = current_dist + weight
            
            # If a shorter path to v is found, update distance and push to queue
            if v not in dist or new_dist < dist[v]:
                dist[v] = new_dist
                heapq.heappush(pq, (new_dist, v))
                
    return dist