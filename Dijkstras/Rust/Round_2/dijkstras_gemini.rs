// Generated by Google Gemini: 2.5 Pro on 12/4/25 9:45 pm 
// https://gemini.google.com/share/26e2619d69b6
use std::cmp::Ordering;
use std::collections::{BinaryHeap, HashMap};

pub type Node = usize;
pub type Weight = f64;
pub type Graph = HashMap<Node, Vec<(Node, Weight)>>;

/// A helper struct to store in the PriorityQueue.
/// We implement `Ord` manually to create a Min-Heap behavior
/// and to handle floating point comparisons.
#[derive(Copy, Clone, PartialEq)]
struct State {
    cost: Weight,
    position: Node,
}

impl Eq for State {}

impl Ord for State {
    fn cmp(&self, other: &State) -> Ordering {
        // Sort by cost first, then by position to break ties.
        // Notice we compare `other.cost` to `self.cost` (reversed)
        // because std::collections::BinaryHeap is a Max-Heap,
        // and we want the lowest cost to be popped first.
        other.cost.partial_cmp(&self.cost)
            .unwrap_or(Ordering::Equal)
            .then_with(|| self.position.cmp(&other.position))
    }
}

impl PartialOrd for State {
    fn partial_cmp(&self, other: &State) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

pub fn dijkstra(graph: &Graph, source: Node) -> HashMap<Node, Weight> {
    // Unreachable nodes are omitted from the result.
    let mut distances: HashMap<Node, Weight> = HashMap::new();
    let mut heap = BinaryHeap::new();

    // Initialize the source node
    distances.insert(source, 0.0);
    heap.push(State { cost: 0.0, position: source });

    while let Some(State { cost, position }) = heap.pop() {
        // If we found a shorter path to this node previously, ignore this stale state.
        // Note: We use unwrap_or(INFINITY) to handle the case, though logic guarantees existence here.
        let current_shortest = *distances.get(&position).unwrap_or(&f64::INFINITY);
        
        if cost > current_shortest {
            continue;
        }

        // If the node has outgoing edges, iterate through them
        if let Some(neighbors) = graph.get(&position) {
            for &(next_node, weight) in neighbors {
                let next_cost = cost + weight;
                
                // Check if we found a cheaper path to next_node
                let is_shorter = match distances.get(&next_node) {
                    Some(&d) => next_cost < d,
                    None => true, // Infinite distance implies any path is shorter
                };

                if is_shorter {
                    distances.insert(next_node, next_cost);
                    heap.push(State { cost: next_cost, position: next_node });
                }
            }
        }
    }

    distances
}