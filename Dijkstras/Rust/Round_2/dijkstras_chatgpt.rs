// Generated by ChatGPT: GPT-5 Thinking Mini on 12/4/25 9:28 pm
// https://chatgpt.com/share/693813ab-9fd0-8008-8111-b82aa98a792f
use std::cmp::{Ordering, Reverse};
use std::collections::{BinaryHeap, HashMap};

pub type Node = usize;
pub type Weight = f64;
pub type Graph = HashMap<Node, Vec<(Node, Weight)>>;

#[derive(Copy, Clone, Debug)]
struct State {
    cost: Weight,
    node: Node,
}

// Implement Ord/PartialOrd using f64::total_cmp so BinaryHeap can order States.
// We keep PartialEq/Eq consistent with the ordering by comparing bit patterns
// for the cost and the node.
impl PartialEq for State {
    fn eq(&self, other: &Self) -> bool {
        self.cost.to_bits() == other.cost.to_bits() && self.node == other.node
    }
}

impl Eq for State {}

impl PartialOrd for State {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for State {
    fn cmp(&self, other: &Self) -> Ordering {
        // total_cmp provides a total ordering for f64 (handles NaN, -0.0, +0.0).
        match self.cost.total_cmp(&other.cost) {
            Ordering::Less => Ordering::Less,
            Ordering::Greater => Ordering::Greater,
            Ordering::Equal => self.node.cmp(&other.node),
        }
    }
}

/// Dijkstra's algorithm using a BinaryHeap (min-heap implemented via Reverse).
///
/// Semantics:
/// - The graph is directed with non-negative edge weights.
/// - graph[&u] (if present) is a list of (v, w) edges meaning an edge u -> v with weight w.
/// - Returns a HashMap<Node, Weight> mapping reachable nodes to their shortest-path distance
/// from source. Unreachable nodes are omitted from the result.
pub fn dijkstra(graph: &Graph, source: Node) -> HashMap<Node, Weight> {
    let mut dist: HashMap<Node, Weight> = HashMap::new();
    let mut heap: BinaryHeap<Reverse<State>> = BinaryHeap::new();

    dist.insert(source, 0.0);
    heap.push(Reverse(State {
        cost: 0.0,
        node: source,
    }));

    while let Some(Reverse(State { cost, node })) = heap.pop() {
        // If we have already found a better path to `node`, skip.
        if let Some(&best) = dist.get(&node) {
            if cost > best {
                continue;
            }
        }

        if let Some(neighbors) = graph.get(&node) {
            for &(v, w) in neighbors {
                // Assume non-negative weights as specified.
                let next = cost + w;
                // Skip invalid arithmetic results (robustness).
                if next.is_nan() {
                    continue;
                }
                let should_update = dist.get(&v).map_or(true, |&old| next < old);
                if should_update {
                    dist.insert(v, next);
                    heap.push(Reverse(State { cost: next, node: v }));
                }
            }
        }
    }

    dist
}