// Generated by Claude: Sonnet 4.5 on 12/4/2025 9:40 pm
// https://claude.ai/share/2058dc8e-d4ab-49d1-afb4-ce39da55efe7
use std::collections::{BinaryHeap, HashMap};
use std::cmp::Ordering;

pub type Node = usize;
pub type Weight = f64;
pub type Graph = HashMap<Node, Vec<(Node, Weight)>>;

#[derive(Copy, Clone)]
struct State {
    node: Node,
    distance: Weight,
}

impl PartialEq for State {
    fn eq(&self, other: &Self) -> bool {
        self.distance == other.distance
    }
}

impl Eq for State {}

impl PartialOrd for State {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for State {
    fn cmp(&self, other: &Self) -> Ordering {
        other.distance.partial_cmp(&self.distance)
            .unwrap_or(Ordering::Equal)
            .then_with(|| self.node.cmp(&other.node))
    }
}

// Returns shortest distances from source to all reachable nodes.
// Unreachable nodes are omitted from the result.
pub fn dijkstra(graph: &Graph, source: Node) -> HashMap<Node, Weight> {
    let mut distances: HashMap<Node, Weight> = HashMap::new();
    let mut heap = BinaryHeap::new();
    
    distances.insert(source, 0.0);
    heap.push(State { node: source, distance: 0.0 });
    
    while let Some(State { node, distance }) = heap.pop() {
        if distance > *distances.get(&node).unwrap_or(&f64::INFINITY) {
            continue;
        }
        
        if let Some(neighbors) = graph.get(&node) {
            for &(neighbor, weight) in neighbors {
                let new_distance = distance + weight;
                let current_distance = distances.get(&neighbor).copied().unwrap_or(f64::INFINITY);
                
                if new_distance < current_distance {
                    distances.insert(neighbor, new_distance);
                    heap.push(State { node: neighbor, distance: new_distance });
                }
            }
        }
    }
    
    distances
}