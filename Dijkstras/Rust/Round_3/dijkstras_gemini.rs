// Generated by Google Gemini: 2.5 Pro on 12/4/25 10:03 pm 
// https://gemini.google.com/share/e49ecbaca262
use std::cmp::Ordering;
use std::collections::{BinaryHeap, HashMap};

pub type Node = usize;
pub type Weight = f64;
pub type Graph = HashMap<Node, Vec<(Node, Weight)>>;

// Helper struct to store state in the priority queue.
// We implement Ord manually to handle f64 and to create a Min-Heap.
#[derive(Copy, Clone, PartialEq)]
struct State {
    cost: Weight,
    position: Node,
}

impl Eq for State {}

impl Ord for State {
    fn cmp(&self, other: &Self) -> Ordering {
        // Notice the order is flipped (other vs self) to create a min-heap.
        // We use unwrap_or because f64 does not implement Ord. 
        // We assume weights are non-negative and not NaN.
        other.cost.partial_cmp(&self.cost).unwrap_or(Ordering::Equal)
    }
}

impl PartialOrd for State {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

pub fn dijkstra(graph: &Graph, source: Node) -> HashMap<Node, Weight> {
    let mut distances = HashMap::new();
    let mut heap = BinaryHeap::new();

    // Initialize the source node with a distance of 0.0
    distances.insert(source, 0.0);
    heap.push(State {
        cost: 0.0,
        position: source,
    });

    while let Some(State { cost, position }) = heap.pop() {
        // Important: If we popped a state that is worse than the shortest distance
        // we've already found for this node, skip it. (Lazy deletion pattern)
        if let Some(&d) = distances.get(&position) {
            if cost > d {
                continue;
            }
        }

        // Examine neighbors if the node exists in the graph
        if let Some(neighbors) = graph.get(&position) {
            for &(next_node, weight) in neighbors {
                let next_cost = cost + weight;

                // Check if we found a shorter path
                let is_shorter = match distances.get(&next_node) {
                    Some(&curr_dist) => next_cost < curr_dist,
                    None => true,
                };

                if is_shorter {
                    distances.insert(next_node, next_cost);
                    heap.push(State {
                        cost: next_cost,
                        position: next_node,
                    });
                }
            }
        }
    }

    // Nodes unreachable from source are omitted from the result map.
    distances
}