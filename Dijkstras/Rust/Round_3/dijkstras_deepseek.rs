// Generated by DeepSeek: V3.2 on 12/4/25 10:01 pm
// https://chat.deepseek.com/share/gdhonbz0cwf1unrblk
use std::collections::{HashMap, BinaryHeap};
use std::cmp::Ordering;

pub type Node = usize;
pub type Weight = f64;
pub type Graph = HashMap<Node, Vec<(Node, Weight)>>;

// Internal struct for heap entries to implement proper ordering
#[derive(Debug, PartialEq)]
struct HeapEntry {
    distance: Weight,
    node: Node,
}

impl Eq for HeapEntry {}

// Reverse ordering for min-heap: BinaryHeap is a max-heap by default,
// so we implement Ord to prioritize smaller distances
impl Ord for HeapEntry {
    fn cmp(&self, other: &Self) -> Ordering {
        // Compare by distance (smaller is better), then by node for tie-breaking
        other.distance
            .partial_cmp(&self.distance)
            .unwrap_or(Ordering::Equal)
            .then_with(|| self.node.cmp(&other.node))
    }
}

impl PartialOrd for HeapEntry {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

pub fn dijkstra(graph: &Graph, source: Node) -> HashMap<Node, Weight> {
    let mut distances: HashMap<Node, Weight> = HashMap::new();
    let mut heap = BinaryHeap::new();
    
    // Start with source node
    distances.insert(source, 0.0);
    heap.push(HeapEntry {
        distance: 0.0,
        node: source,
    });
    
    while let Some(HeapEntry { distance, node }) = heap.pop() {
        // Skip stale entries (if we found a better distance already)
        if let Some(&best_dist) = distances.get(&node) {
            if distance > best_dist {
                continue;
            }
        }
        
        // Process neighbors
        if let Some(neighbors) = graph.get(&node) {
            for &(neighbor, weight) in neighbors {
                let new_distance = distance + weight;
                
                // Update distance if we found a shorter path
                let should_push = match distances.get(&neighbor) {
                    Some(&current_dist) => new_distance < current_dist,
                    None => true,
                };
                
                if should_push {
                    distances.insert(neighbor, new_distance);
                    heap.push(HeapEntry {
                        distance: new_distance,
                        node: neighbor,
                    });
                }
            }
        }
    }
    
    distances
}