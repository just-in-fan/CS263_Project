// Generated by ChatGPT: GPT-5 Thinking Mini on 12/4/25 9:58 pm
// https://chatgpt.com/share/693814d5-3784-8008-8739-49fd551a53ea
use std::cmp::Ordering;
use std::collections::{BinaryHeap, HashMap};

pub type Node = usize;
pub type Weight = f64;
pub type Graph = HashMap<Node, Vec<(Node, Weight)>>;

/// Dijkstra's algorithm returning a map of shortest distances from `source`.
/// Convention: unreachable nodes are **omitted** from the returned `HashMap`.
pub fn dijkstra(graph: &Graph, source: Node) -> HashMap<Node, Weight> {
    #[derive(Copy, Clone, Debug)]
    struct State {
        cost: Weight,
        node: Node,
    }

    // Implement ordering so that BinaryHeap acts as a min-heap by `cost`.
    impl Eq for State {}

    impl PartialEq for State {
        fn eq(&self, other: &Self) -> bool {
            self.cost.to_bits() == other.cost.to_bits() && self.node == other.node
        }
    }

    impl PartialOrd for State {
        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
            Some(self.cmp(other))
        }
    }

    impl Ord for State {
        fn cmp(&self, other: &Self) -> Ordering {
            // Use total_cmp for a total ordering on f64, and reverse the comparison
            // so that the smallest cost is considered the "largest" for BinaryHeap.
            match other.cost.total_cmp(&self.cost) {
                Ordering::Equal => self.node.cmp(&other.node),
                ord => ord,
            }
        }
    }

    let mut dist: HashMap<Node, Weight> = HashMap::new();
    let mut heap: BinaryHeap<State> = BinaryHeap::new();

    dist.insert(source, 0.0);
    heap.push(State {
        cost: 0.0,
        node: source,
    });

    while let Some(State { cost, node }) = heap.pop() {
        // If we have already found a better path to `node`, skip.
        if let Some(&best) = dist.get(&node) {
            if cost > best {
                continue;
            }
        }

        if let Some(neighbors) = graph.get(&node) {
            for &(v, w) in neighbors.iter() {
                // Assumes non-negative weights as specified.
                let next = cost + w;
                let known = dist.get(&v).cloned().unwrap_or(f64::INFINITY);
                if next < known {
                    dist.insert(v, next);
                    heap.push(State { cost: next, node: v });
                }
            }
        }
    }

    dist
}
