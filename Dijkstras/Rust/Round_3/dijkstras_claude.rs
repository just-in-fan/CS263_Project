// Generated by Claude: Sonnet 4.5 on 12/4/2025 9:52 pm
// https://claude.ai/share/6923f314-a264-4a9d-bf8f-e5d1f64d16d9
use std::collections::{HashMap, BinaryHeap};
use std::cmp::Reverse;

pub type Node = usize;
pub type Weight = f64;
pub type Graph = HashMap<Node, Vec<(Node, Weight)>>;

#[derive(Copy, Clone, PartialEq)]
struct State {
    cost: Weight,
    node: Node,
}

impl Eq for State {}

impl PartialOrd for State {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for State {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.cost.partial_cmp(&other.cost).unwrap_or(std::cmp::Ordering::Equal)
    }
}

// Returns shortest distances from source to all reachable nodes.
// Unreachable nodes are omitted from the result.
pub fn dijkstra(graph: &Graph, source: Node) -> HashMap<Node, Weight> {
    let mut distances: HashMap<Node, Weight> = HashMap::new();
    let mut heap: BinaryHeap<Reverse<State>> = BinaryHeap::new();

    distances.insert(source, 0.0);
    heap.push(Reverse(State { cost: 0.0, node: source }));

    while let Some(Reverse(State { cost, node })) = heap.pop() {
        if let Some(&current_dist) = distances.get(&node) {
            if cost > current_dist {
                continue;
            }
        }

        if let Some(neighbors) = graph.get(&node) {
            for &(neighbor, weight) in neighbors {
                let new_cost = cost + weight;
                let is_shorter = distances
                    .get(&neighbor)
                    .map_or(true, |&current| new_cost < current);

                if is_shorter {
                    distances.insert(neighbor, new_cost);
                    heap.push(Reverse(State { cost: new_cost, node: neighbor }));
                }
            }
        }
    }

    distances
}