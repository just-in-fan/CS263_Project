// Generated by DeepSeek: V3.2 on 12/3/25 9:34 pm
// https://chat.deepseek.com/share/srtvf1tjw9196o1iw7
use std::collections::{BinaryHeap, HashMap};
use std::cmp::Ordering;

pub type Node = usize;
pub type Weight = f64;
pub type Graph = HashMap<Node, Vec<(Node, Weight)>>;

// Min-heap entry: (distance, node)
#[derive(Debug)]
struct HeapEntry(Weight, Node);

impl PartialEq for HeapEntry {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl Eq for HeapEntry {}

impl PartialOrd for HeapEntry {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        // Reverse comparison for min-heap (smaller distance = higher priority)
        other.0.partial_cmp(&self.0)
    }
}

impl Ord for HeapEntry {
    fn cmp(&self, other: &Self) -> Ordering {
        self.partial_cmp(other).unwrap_or(Ordering::Equal)
    }
}

pub fn dijkstra(graph: &Graph, source: Node) -> HashMap<Node, Weight> {
    let mut distances = HashMap::new();
    let mut heap = BinaryHeap::new();
    
    distances.insert(source, 0.0);
    heap.push(HeapEntry(0.0, source));
    
    while let Some(HeapEntry(current_dist, current)) = heap.pop() {
        // Skip stale entries (if we found a better path already)
        if let Some(&best_dist) = distances.get(&current) {
            if current_dist > best_dist {
                continue;
            }
        }
        
        // Process neighbors
        if let Some(neighbors) = graph.get(&current) {
            for &(neighbor, edge_weight) in neighbors {
                let new_dist = current_dist + edge_weight;
                
                match distances.get(&neighbor) {
                    Some(&old_dist) if new_dist >= old_dist => {
                        // Not an improvement
                        continue;
                    }
                    _ => {
                        distances.insert(neighbor, new_dist);
                        heap.push(HeapEntry(new_dist, neighbor));
                    }
                }
            }
        }
    }
    
    distances
}