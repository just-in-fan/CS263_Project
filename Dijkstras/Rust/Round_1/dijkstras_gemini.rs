// Generated by Google Gemini: 2.5 Pro on 12/3/25 9:56 pm 
// https://gemini.google.com/share/d6f365eea00e
use std::cmp::Ordering;
use std::collections::{BinaryHeap, HashMap};

pub type Node = usize;
pub type Weight = f64;
pub type Graph = HashMap<Node, Vec<(Node, Weight)>>;

// A struct to hold state in the priority queue.
// We implement Ord to handle f64 comparisons and min-heap logic.
#[derive(Copy, Clone, PartialEq)]
struct State {
    cost: Weight,
    position: Node,
}

// Eq is required for BinaryHeap.
impl Eq for State {}

// We need Ord for BinaryHeap.
// Since we want a min-heap (shortest path), we flip the ordering here:
// comparing `other` to `self` means smaller costs sort as "greater" (higher priority).
impl Ord for State {
    fn cmp(&self, other: &Self) -> Ordering {
        other.cost.partial_cmp(&self.cost).unwrap_or(Ordering::Equal)
    }
}

// PartialOrd must be consistent with Ord.
impl PartialOrd for State {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

pub fn dijkstra(graph: &Graph, source: Node) -> HashMap<Node, Weight> {
    // Distance map to store the shortest path found so far to each node.
    // Unreachable nodes will simply be omitted from this map.
    let mut dist: HashMap<Node, Weight> = HashMap::new();
    let mut heap = BinaryHeap::new();

    // Initialize the source node with distance 0.0
    dist.insert(source, 0.0);
    heap.push(State {
        cost: 0.0,
        position: source,
    });

    while let Some(State { cost, position }) = heap.pop() {
        // If the popped node already has a shorter distance in the map,
        // we can skip processing it (it's an outdated entry).
        if let Some(&d) = dist.get(&position) {
            if cost > d {
                continue;
            }
        }

        // Iterate over neighbors if the node exists in the graph
        if let Some(neighbors) = graph.get(&position) {
            for &(neighbor, weight) in neighbors {
                let next_cost = cost + weight;

                // Check if we found a shorter path to the neighbor
                let is_shorter = match dist.get(&neighbor) {
                    Some(&d) => next_cost < d,
                    None => true,
                };

                if is_shorter {
                    dist.insert(neighbor, next_cost);
                    heap.push(State {
                        cost: next_cost,
                        position: neighbor,
                    });
                }
            }
        }
    }

    dist
}