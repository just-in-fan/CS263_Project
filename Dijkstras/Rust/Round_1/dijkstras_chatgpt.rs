// Generated by ChatGPT: GPT-5 Thinking Mini on 12/3/25 9:29 pm
// https://chatgpt.com/share/69311d23-1b48-8008-9952-54d173f59cba
use std::cmp::Ordering;
use std::collections::{BinaryHeap, HashMap};

pub type Node = usize;
pub type Weight = f64;
pub type Graph = HashMap<Node, Vec<(Node, Weight)>>;

/// Dijkstra's shortest-path algorithm using a BinaryHeap-based min-heap.
/// Nodes unreachable from source are omitted from the returned HashMap.
pub fn dijkstra(graph: &Graph, source: Node) -> HashMap<Node, Weight> {
    #[derive(Debug, Clone)]
    struct State {
        cost: Weight,
        node: Node,
    }

    // Implement Ord so BinaryHeap behaves as a min-heap by reversing the cost comparison.
    impl Eq for State {}
    impl PartialEq for State {
        fn eq(&self, other: &Self) -> bool {
            self.cost == other.cost && self.node == other.node
        }
    }
    impl PartialOrd for State {
        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
            Some(self.cmp(other))
        }
    }
    impl Ord for State {
        fn cmp(&self, other: &Self) -> Ordering {
            // Use total_cmp for a fully ordered comparison of f64 (handles -0.0, etc.).
            // We flip the order to turn Rust's max-heap into a min-heap.
            other
                .cost
                .total_cmp(&self.cost)
                .then_with(|| self.node.cmp(&other.node))
        }
    }

    let mut dist: HashMap<Node, Weight> = HashMap::new();
    let mut heap: BinaryHeap<State> = BinaryHeap::new();

    dist.insert(source, 0.0);
    heap.push(State {
        cost: 0.0,
        node: source,
    });

    while let Some(State { cost, node }) = heap.pop() {
        // Skip stale heap entries
        if let Some(&current) = dist.get(&node) {
            if cost > current {
                continue;
            }
        }

        if let Some(neighbors) = graph.get(&node) {
            for &(v, w) in neighbors.iter() {
                // Assumes non-negative weights as specified.
                let next_cost = cost + w;
                if dist.get(&v).map_or(true, |&old| next_cost < old) {
                    dist.insert(v, next_cost);
                    heap.push(State {
                        cost: next_cost,
                        node: v,
                    });
                }
            }
        }
    }

    dist
}