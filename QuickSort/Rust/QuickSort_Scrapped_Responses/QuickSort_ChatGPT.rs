// Generated by ChatGPT: GPT-5 Thinking Mini on 11/28/25 4:18 pm
// https://chatgpt.com/share/692a4ab9-6500-8008-87d4-591fb3d9e6a4
// Generic in-place quicksort using the Lomuto partition scheme.
fn quicksort<T: Ord>(arr: &mut [T]) {
    let len = arr.len();
    if len <= 1 {
        return;
    }

    let p = partition(arr);
    // split_at_mut returns (left, right) where right starts at pivot index
    let (left, right) = arr.split_at_mut(p);
    quicksort(left);
    // skip the pivot at right[0]
    quicksort(&mut right[1..]);
}

fn partition<T: Ord>(arr: &mut [T]) -> usize {
    let len = arr.len();
    // use last element as pivot
    let pivot_index = len - 1;
    let mut i = 0usize;

    for j in 0..pivot_index {
        // compare via references; works when T: Ord
        if &arr[j] <= &arr[pivot_index] {
            arr.swap(i, j);
            i += 1;
        }
    }
    arr.swap(i, pivot_index);
    i
}

fn main() {
    let mut v = vec![3, 6, 8, 10, 1, 2, 1];
    println!("before: {:?}", v);
    quicksort(&mut v);
    println!("after:  {:?}", v);

    let mut empty: Vec<i32> = vec![];
    quicksort(&mut empty);
    assert!(empty.is_empty());

    let mut single = vec![42];
    quicksort(&mut single);
    assert_eq!(single, vec![42]);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn sorts_numbers() {
        let mut v = vec![5, 3, 8, 1, 2, 7];
        quicksort(&mut v);
        assert_eq!(v, vec![1, 2, 3, 5, 7, 8]);
    }

    #[test]
    fn sorts_duplicates_and_negatives() {
        let mut v = vec![0, -1, 5, 0, 3, -1];
        quicksort(&mut v);
        assert_eq!(v, vec![-1, -1, 0, 0, 3, 5]);
    }

    #[test]
    fn already_sorted() {
        let mut v = vec![1, 2, 3, 4, 5];
        quicksort(&mut v);
        assert_eq!(v, vec![1, 2, 3, 4, 5]);
    }
}
